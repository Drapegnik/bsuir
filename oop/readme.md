# oop

> Перспективные технологии объектно-ориентированного программирования (ПТООП)

- [@Drapegnik/oop-paint](https://github.com/Drapegnik/oop-paint)
- [@vanashimko/shapes-drawer](https://github.com/vanashimko/shapes-drawer)
- [@vanashimko/employees-list-editor](https://github.com/vanashimko/employees-list-editor)
- [@MinchukSergei/PTOOP](https://github.com/MinchukSergei/PTOOP)
- [@pavel-ulasavets/magistracy-ptoop](https://github.com/pavel-ulasavets/magistracy-ptoop)
- [@zzhukanton/PTOOP](https://github.com/zzhukanton/PTOOP)
- [@demidov91/university-oop-geometry](https://github.com/demidov91/university-oop-geometry)

## tasks

### 1. Ознакомление с концепциями ООП: наследование и полиморфизм типов (виртуальные методы)

- Построить иерархию классов для вывода графических фигур: `отрезок`, `прямоугольник`, `эллипс` и т.д - не менее 6 фигур.
- Распределить классы по модулям.
- Создать список фигур в виде отдельного класса.
- В главном модуле программы добавить в список различные фигуры (статическая инициализация), после чего запустить рисование списка фигур.
- Выполнить задание на языке **C++**, **C#** или **Java**.
- Для рисования использовать любую подходящую графическую библиотеку.
- Если изучение графической библиотеки вызывает затруднение, допускается вывод фигур в файл или на экран в виде текстовых строк вида `Rectangle(10, 20, 30, 40)`.

### 2. «Графический редактор»

- Расширить пример с графическими фигурами (`#1`) так, чтобы фигуры можно было создавать на уровне пользовательского интерфейса.
- Существуют несколько способов (выбрать любой способ ввода):
  - ввод координат с помощью мыши;
  - диалоговый ввод значений;
  - ввод на скриптовом языке.
- Создание объекта должно выполняться так, чтобы добавление нового класса в систему не требовало изменения существующего кода (выбор типа с помощью оператора `case`/`switch` и множественного `if` делать нельзя).
- Получившаяся программа должна представлять собой примитивный графический редактор.
- Классы фигур не должны содержать метод рисования.

### 3. «Сериализация объектов»

- Выбрать предметную область и построить иерархию классов.
- Иерархия должна включать не менее 6 классов.
- Реализовать _сериализацию_/_десереализацию_ объектов из полученной иерархии классов в файл/из файла, формат сериализации определяется индивидуальным вариантом.
- В пользовательском интерфейсе необходимо реализовать следующие функции:
  - возможность изменять свойства объектов (редактирование);
  - добавлять/удалять объекты из списка;
  - _сериализация_/_десериализация_ списка объектов.
- Добавление новых классов в иерархию не должно приводить к необходимости переписать существующий код, и не использовать `if`-`else`/`switch`-`case`, рефлексию.
- Опционально: реализация графического интерфейса.

#### Варианты

| #   | format   |
| --- | -------- |
| 1   | `XML`    |
| 2   | `Binary` |
| 3   | `Text`   |
| 4   | `JSON`   |
| 5   | `BSON`   |

### 4. «Плагины - иерархия»

#### Задание на 8 баллов (обязательное):

- На основе лабораторной работы `#2` или `#3` расширить имеющуюся иерархию новыми классами с помощью динамической загрузки модуля (плагина).
- Новые модули должны добавлять или расширять функциональность базовой программы:
  - новый класс в иерархии
  - функции по работе с ним
  - новые элементы в пользовательском интерфейсе для работы с новым классом
- Загружать модули можно из папки либо посредством строки-параметра в главном модуле с именем нового модуля и возможной перекомпиляцией.
- В идеале добавление нового модуля должно выполняться его динамической загрузкой, т.е. вообще не должно требовать изменения кода программы.

#### Задание на 10 баллов (опционально):

- Сделать подпись плагина с последующей проверкой базовой программой данной подписи на достоверность (время активации и целостность).
- Разработать механизм подписывания плагинов.

### 5. «Плагины - функциональность»

#### Задание на 8 баллов (обязательное):

- На базе предыдущей лабораторной работы (`#4`) на основе плагинов (2-3 плагина) реализовать возможность обработки структур перед сохранением в файл и после загрузки из файла.
- Тип обработки задается вариантом.
- Дополнительная функциональность должна находиться в меню настроек и зависит от загруженных плагинов.
- Загрузка плагинов производится автоматически из папки, либо выбором файла с плагином через пользовательский интерфейс.

#### Задание на 10 баллов (дополнительное):

- Предусмотреть дополнительную настройку функциональности плагина в меню настройки плагинов.
- Например, заданием параметров шифрования/архивации, выбор алгоритма шифрования, дополнительные правила трансформации, кодировки и т.д.

#### Варианты

| #   | Тип обработки                       |
| --- | ----------------------------------- |
| 1   | Трансформация `XML` данных в `JSON` |
| 2   | Архивация                           |
| 3   | Шифрования/дешифрование             |
| 4   | Трансформация `XML` (можно `XSLT`)  |
| 5   | Сохранение контрольной суммы        |

### 6. «Паттерны»

- На базе предыдущей лабораторной работы (`#5`) обменяться с товарищем функциональными плагинами (минимум одним) и адаптировать их в этой же работе помощью паттерна `Адаптер` (т.е. появятся новые функции от плагина товарища, загруженные через плагин с адаптером).
- Также необходимо реализовать 2 паттерна (любых) в программе, пояснив уместность их использования.

---

> Номер варианта определяется по формуле:

- `(<порядковый номер в группе> mod <количество вариантов>) + 1`

> Проект должен разрабатываться с использование системы контроля версий `git`/`svn`. Все функции/процедуры, большие блоки кода должны содержать комментарии. Язык комментариев - английский.
